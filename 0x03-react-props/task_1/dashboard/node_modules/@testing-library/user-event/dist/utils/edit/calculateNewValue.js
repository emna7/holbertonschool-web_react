"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateNewValue = calculateNewValue;

var _getSelectionRange = require("./getSelectionRange");

var _getValue = require("./getValue");

var _isValidDateValue = require("./isValidDateValue");

var _isValidInputTimeValue = require("./isValidInputTimeValue");

function calculateNewValue(newEntry, element, value = (0, _getValue.getValue)(element), selectionRange = (0, _getSelectionRange.getSelectionRange)(element)) {
  const {
    selectionStart,
    selectionEnd
  } = selectionRange;
  let newValue, newSelectionStart;

  if (selectionStart === null) {
    // at the end of an input type that does not support selection ranges
    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793
    newValue = `${value}${newEntry}`;
    newSelectionStart = newValue.length;
  } else if (selectionStart === selectionEnd) {
    if (selectionStart === 0) {
      // at the beginning of the input
      newValue = `${newEntry}${value}`;
    } else if (selectionStart === (value == null ? void 0 : value.length)) {
      // at the end of the input
      newValue = `${value}${newEntry}`;
    } else {
      // in the middle of the input
      newValue = `${value == null ? void 0 : value.slice(0, selectionStart)}${newEntry}${value == null ? void 0 : value.slice(selectionEnd)}`;
    }

    newSelectionStart = selectionStart + newEntry.length;
  } else {
    // we have something selected
    const firstPart = `${value == null ? void 0 : value.slice(0, selectionStart)}${newEntry}`;
    newValue = `${firstPart}${value == null ? void 0 : value.slice(selectionEnd)}`;
    newSelectionStart = firstPart.length;
  }

  if (element.type === 'date' && !(0, _isValidDateValue.isValidDateValue)(element, newValue)) {
    newValue = value;
  }

  if (element.type === 'time' && !(0, _isValidInputTimeValue.isValidInputTimeValue)(element, newValue)) {
    if ((0, _isValidInputTimeValue.isValidInputTimeValue)(element, newEntry)) {
      newValue = newEntry;
    } else {
      newValue = value;
    }
  } // can't use .maxLength property because of a jsdom bug:
  // https://github.com/jsdom/jsdom/issues/2927


  const maxLength = getSanitizedMaxLength(element);

  if (maxLength === undefined) {
    return {
      newValue,
      newSelectionStart
    };
  } else {
    return {
      newValue: newValue.slice(0, maxLength),
      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart
    };
  }
}

function getSanitizedMaxLength(element) {
  var _element$getAttribute;

  if (!supportsMaxLength(element)) {
    return undefined;
  }

  const attr = (_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : '';
  return /^\d+$/.test(attr) && Number(attr) >= 0 ? Number(attr) : undefined;
}

function supportsMaxLength(element) {
  if (element.tagName === 'TEXTAREA') return true;

  if (element.tagName === 'INPUT') {
    const type = element.getAttribute('type'); // Missing value default is "text"

    if (!type) return true; // https://html.spec.whatwg.org/multipage/input.html#concept-input-apply

    if (type.match(/email|password|search|telephone|text|url/)) return true;
  }

  return false;
}