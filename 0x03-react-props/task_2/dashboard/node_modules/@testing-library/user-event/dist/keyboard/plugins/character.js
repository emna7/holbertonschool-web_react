"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keypressBehavior = void 0;

var _dom = require("@testing-library/dom");

var _shared = require("../shared");

var _utils = require("../../utils");

/**
 * This file should cover the behavior for keys that produce character input
 */
const keypressBehavior = [{
  matches: (keyDef, element) => {
    var _keyDef$key;

    return ((_keyDef$key = keyDef.key) == null ? void 0 : _keyDef$key.length) === 1 && (0, _utils.isInstanceOfElement)(element, 'HTMLInputElement') && element.type === 'time';
  },
  handle: (keyDef, element, options, state) => {
    var _state$carryValue;

    let newEntry = keyDef.key;
    const textToBeTyped = ((_state$carryValue = state.carryValue) != null ? _state$carryValue : '') + newEntry;
    const timeNewEntry = (0, _utils.buildTimeValue)(textToBeTyped);

    if ((0, _utils.isValidInputTimeValue)(element, timeNewEntry)) {
      newEntry = timeNewEntry;
    }

    const {
      newValue,
      newSelectionStart
    } = (0, _utils.calculateNewValue)(newEntry, element);
    const {
      prevValue
    } = (0, _shared.fireInputEventIfNeeded)({
      newValue,
      newSelectionStart,
      eventOverrides: {
        data: keyDef.key,
        inputType: 'insertText'
      },
      currentElement: () => element
    });
    (0, _shared.fireChangeForInputTimeIfValid)(element, prevValue, timeNewEntry);
    state.carryValue = textToBeTyped;
  }
}, {
  matches: (keyDef, element) => {
    var _keyDef$key2;

    return ((_keyDef$key2 = keyDef.key) == null ? void 0 : _keyDef$key2.length) === 1 && (0, _utils.isInstanceOfElement)(element, 'HTMLInputElement') && element.type === 'date';
  },
  handle: (keyDef, element, options, state) => {
    var _state$carryValue2;

    let newEntry = keyDef.key;
    const textToBeTyped = ((_state$carryValue2 = state.carryValue) != null ? _state$carryValue2 : '') + newEntry;
    const isValidToBeTyped = (0, _utils.isValidDateValue)(element, textToBeTyped);

    if (isValidToBeTyped) {
      newEntry = textToBeTyped;
    }

    const {
      newValue,
      newSelectionStart
    } = (0, _utils.calculateNewValue)(newEntry, element);
    (0, _shared.fireInputEventIfNeeded)({
      newValue,
      newSelectionStart,
      eventOverrides: {
        data: keyDef.key,
        inputType: 'insertText'
      },
      currentElement: () => element
    });

    if (isValidToBeTyped) {
      _dom.fireEvent.change(element, {
        target: {
          value: textToBeTyped
        }
      });
    }

    state.carryValue = textToBeTyped;
  }
}, {
  matches: (keyDef, element) => {
    var _keyDef$key3;

    return ((_keyDef$key3 = keyDef.key) == null ? void 0 : _keyDef$key3.length) === 1 && (0, _utils.isInstanceOfElement)(element, 'HTMLInputElement') && element.type === 'number';
  },
  handle: (keyDef, element, options, state) => {
    var _ref, _state$carryValue3;

    if (!/[\d.\-e]/.test(keyDef.key)) {
      return;
    }

    const oldValue = (_ref = (_state$carryValue3 = state.carryValue) != null ? _state$carryValue3 : (0, _utils.getValue)(element)) != null ? _ref :
    /* istanbul ignore next */
    '';
    const {
      newValue,
      newSelectionStart
    } = (0, _utils.calculateNewValue)(keyDef.key, element, oldValue);
    (0, _shared.fireInputEventIfNeeded)({
      newValue,
      newSelectionStart,
      eventOverrides: {
        data: keyDef.key,
        inputType: 'insertText'
      },
      currentElement: () => element
    });
    const appliedValue = (0, _utils.getValue)(element);

    if (appliedValue === newValue) {
      state.carryValue = undefined;
    } else {
      state.carryValue = newValue;
    }
  }
}, {
  matches: (keyDef, element) => {
    var _keyDef$key4;

    return ((_keyDef$key4 = keyDef.key) == null ? void 0 : _keyDef$key4.length) === 1 && ((0, _utils.isInstanceOfElement)(element, 'HTMLInputElement') || (0, _utils.isInstanceOfElement)(element, 'HTMLTextAreaElement') || (0, _utils.isContentEditable)(element));
  },
  handle: (keyDef, element) => {
    const {
      newValue,
      newSelectionStart
    } = (0, _utils.calculateNewValue)(keyDef.key, element);
    (0, _shared.fireInputEventIfNeeded)({
      newValue,
      newSelectionStart,
      eventOverrides: {
        data: keyDef.key,
        inputType: 'insertText'
      },
      currentElement: () => element
    });
  }
}, {
  matches: (keyDef, element) => keyDef.key === 'Enter' && ((0, _utils.isInstanceOfElement)(element, 'HTMLTextAreaElement') || (0, _utils.isContentEditable)(element)),
  handle: (keyDef, element) => {
    const {
      newValue,
      newSelectionStart
    } = (0, _utils.calculateNewValue)('\n', element);
    (0, _shared.fireInputEventIfNeeded)({
      newValue,
      newSelectionStart,
      eventOverrides: {
        inputType: 'insertLineBreak'
      },
      currentElement: () => element
    });
  }
}];
exports.keypressBehavior = keypressBehavior;